(function() {
  var circles3, empty_svg, init_svg, rect1, rect3, shapes, title;

  empty_svg = function() {
    return d3.select('div.output').append('svg').attr("width", 500).attr("height", 666);
  };

  shapes = function() {
    var svg;
    svg = d3.select('div.output').append('svg').attr("width", 400).attr("height", 300);
    svg.append("circle").attr("class", "myCircles").attr("id", "circle_top").attr("cx", 40).attr("cy", 60).attr("r", 30);
    svg.append("circle").attr("class", "myCircles").attr("id", "circle_bottom").attr("cx", 40).attr("cy", 120).attr("r", 20);
    svg.append("rect").attr("x", 100).attr("y", 60).attr("width", 30).attr("height", 50).style("fill", "orange");
    return svg.append("line").attr("x2", 250).attr("y2", 90).attr("x1", 150).attr("y1", 60).attr("stroke", "black").attr("stroke-width", 2);
  };

  circles3 = function() {
    var svg;
    svg = d3.select('div.output').append('svg').attr("width", 400).attr("height", 300);
    svg.append("circle").attr("cx", 40).attr("cy", 60).attr("r", 10);
    svg.append("circle").attr("cx", 140).attr("cy", 60).attr("r", 10);
    return svg.append("circle").attr("cx", 240).attr("cy", 60).attr("r", 10);
  };

  rect1 = function() {
    var svg;
    svg = d3.select('div.output').append('svg');
    return svg.append("rect").attr("x", 150).attr("y", 100).attr("width", 60).attr("height", 300);
  };

  rect3 = function() {
    var svg;
    svg = d3.select('div.output').append('svg');
    svg.append("rect").attr("x", 200).attr("y", 300).attr("width", 40).attr("height", 50);
    svg.append("rect").attr("x", 100).attr("y", 20).attr("width", 30).attr("height", 50);
    return svg.append("rect").attr("x", 10).attr("y", 200).attr("width", 25).attr("height", 90);
  };

  // ----------------------------------------------------
  slide.title("A basic understanding of JavaScript will save you a lot of pain when you go to build something");

  slide.code("JavaScript Basics", null, "// Single line comments can be written like this\n\n/* \n  And multi-line comments like this\n*/\n\n// To print output we use console.log()\nconsole.log(\"Hello World!\");\n\n// Whitespace (including newlines) is ignored so..\nconsole.log(\"Single line\");\n\n// is the same as\nconsole\n    .log(\n             \"Not a single line\"     );\n\n// Statements are ended with semi-colons\nconsole.log(\"So we can\"); console.log(\"do this\");");

  slide.code("JavaScript Variables: Numbers", null, "// Javascript variables are defined with 'let' and 'var'\n\n// A variable declared with 'let' can only be accessed\n// in the scope it's declared\n\n// A variable declared with 'var' can be accessed\n// outsude the scope\n// Example - Within a for-loop\n\n// Javascript constants are defined with 'const'\n// Constants cannot be re-assigned\n\n// Javascript variables are dynamically typed (like python)\n\n// Their names must start with a alphabetic \n// character and can consist of integers\n// and underscores\n\n// There is only one number type (float64)\nlet age = 45;\n\n// There is no integer type, so there is no\n// worry of integer division (python 2)\n// or integer overflow\nconsole.log(\"45 = \", 45);\nconsole.log(\"45.0 = \", 45.0);\n\n// Scientific notation is achieved with 'e'\n// xey = x * 10^y\nconsole.log(\"1e+1 = \", 1e+1);\nconsole.log(\"1e+2 = \", 1e+2);\nconsole.log(\"1e-2 = \", 1e-2);\n\n// Javascript also defines any number larger\n// than 1.7976931348623157e+308 as infinity\nconsole.log(1.79769313486231570e+308);\nconsole.log(\"Anything >= 1.8e+308 = \", 1.8e+308);");

  slide.code("JavaScript Variables: Strings", null, "// Strings work about the same as python\n// You can use \" \" or '' to define them:\nlet name = \"Bojack\";\nlet lastName = 'Horseman';\n\n// We can concatenate strings with + \nconsole.log(name + \" \" + lastName);\n\n// And \\ is the escape character \nconsole.log(name + \" is \\\"great\\\"\");\n\n// We can also mix quotes for the same effect\nconsole.log(name + ' is \"great\"');\n\n// Multi-line strings require you escape\n// the carridge-return:\nconsole.log(\"Multi \\\n.............Line\");\n\n// We can also use + to convert strings to numbers\nlet numString = +\"55\";\nconsole.log(numString + 1);\n\nlet stringNum = \"55\";\nconsole.log(stringNum + 1);\n\n// We can also check the type of a variable\n// with the typeof operator\nconsole.log(\"numString is a \" + typeof numString);\nconsole.log(\"stringNum is a \" + typeof stringNum);");

  slide.code("Template Literals", null, "// Cleaner way to concatenate strings\n// Uses ``\n// Use ${<variable-name>} in the middle of template literals\nlet name = \"Bojack\";\nlet lastName = 'Horseman';\n\n// We can concatenate strings with + \nconsole.log(`${name} ${lastName}`);\nconsole.log(`First name: ${name}, Last name: ${lastName}`);\n\n// More succint syntax compared to concatenation with \"+\"\n// We will use template literals in this tutorials in many places\n// instead of \"+\" to concatenate strings");

  slide.code("JavaScript Arrays", null, "// Arrays are squences of elements with integer\n// property names:\n\nlet empty = [];\n\nlet numbers = [\n   'zero', 'one', 'two', 'three', 'four',\n   'five', 'six', 'seven', 'eight', 'nine'\n];\n\nconsole.log(\"empty[1] = \" + empty[1]);\nconsole.log(\"numbers[1] = \", numbers[1]);\n\n// We can also index with strings\nconsole.log(\"numbers['1'] = \", numbers['1']);\n\n// Arrays can hold any mixture of values\nlet misc = [\n       'string', 98.6, true, false, null, undefined,\n       ['nested', 'array'], {object: true}, NaN,\n       Infinity\n   ];\n\n// Arrays also have a useful length attribute\nconsole.log(\"empty.length = \" + empty.length);\nconsole.log(\"numbers.length = \" + numbers.length);\nconsole.log(\"misc.length = \" + misc.length);");

  slide.code("JavaScript Array Methods", null, "// Arrays have a set of methods which are included:\nlet a = ['a', 'b', 'c'];\nlet b = ['x', 'y', 'z'];\n\n// Concat:\nlet c = a.concat(b, true);\nconsole.log(\"a.concat(b, true) = \", c);\n\n// Pop:\nc = a.pop();\nconsole.log(\"a.pop() =\", c);\nconsole.log(\"a = \", a);\n\n// Push:\nc = a.push('d');\nconsole.log(\"a.push() =\", c); // new length\nconsole.log(\"a = \", a);\n\n// Slice:\na = [1,2,3,4,5,6];\nlet a_end = a.slice(2);\nlet a_mid = a.slice(2,4);\nconsole.log(\"a.slice(2): \", a_end);\nconsole.log(\"a.slice(2,4): \" + a_mid);\n\n// Filter:\na = [1,4,8,10,3,12,2];\nlet a_big = a.filter(function (d) {return d > 9;});\nconsole.log(\"a.filter(function (d) {return d > 9;}) = \", a_big);\n\n// And many more...\n// array.reverse()\n// array.sort()\n// array.shift()\n// array.splice()");

  slide.code("JavaScript Objects", null, "// Objects are defined with curly braces \n// surrounding zero or more name/value pairs\nlet empty_object = {};\n\n// Names can be specified with or without quotes\nlet actor = {\n     \"first-name\": \"Bojack\",\n     last_name: \"Horseman\"\n     };\n\n// Values can be anything, including objects\nlet course = {\n    title: \"Data Visualization\",\n    dept: \"DSE\",\n    number: 241,\n    professor: {\n        first_name: \"Amit\",\n        last_name: \"Chourasia\"\n      }\n  };\n\n// Values are retrieved by wrapping the string\n// name in [] or using . notation for legal\n// Javascript names\nconsole.log(actor[\"first-name\"], actor.last_name);\nconsole.log(course.title, course.number);\n");

  slide.code("JavaScript Objects", null, "let course = {\n    title: \"Data Visualization\",\n    dept: \"DSE\",\n    number: 241,\n    professor: {\n        first_name: \"Amit\",\n        last_name: \"Chourasia\"\n      }\n  };\n\n// Object properties can be replaced\ncourse.title = \"Computer Stuff\";\n\n// Or if they dont exist, they will be created\ncourse.room = \"Dungeon\";\nconsole.log(\"course.room:\", course.room);\n\n// Also note objects are always passed by \n// reference and never copied\nlet course2 = course;\ncourse2.room = \"Above Ground!\"\n\nconsole.log(\"course.room: \", course.room);\nconsole.log(\"course2.room: \", course2.room);\n\n// Properties can be deleted\ndelete course.room;");

  slide.code("Operations and Comparisons", null, "// Application of operators follows standard\n// order of operations:\n// . [] ()       Accessing & grouping\n// * / %         Mul, Div, Mod\n// + -           Add, Subtract\n// >= <= > <     Ineqality\n// === !==       Equal-to, NEQ\n// &&            Logical AND\n// ||            Logical OR\n// ?:            Ternary\nconsole.log(6*10 + 5 * (2 - 3));\n\nlet divByZero = 100.0 / 0.0;\nlet zeroOverZero = 0.0 / 0.0;\n\nconsole.log(\"100.0 / 0.0 = \" + divByZero);\nconsole.log(\"0.0 / 0.0 = \" + zeroOverZero);\n\n// Equality returns booleans\nconsole.log(\"5 === 5: \", 5 === 5);\nconsole.log(\"5 === 6: \", 5 === 6);\nconsole.log(\"5 === '5': \", 5 === '5');\n\n// Don't use == for equality...\nconsole.log('\\t\\r\\n ' == 0);\n\n// === checks strick equality\n// == performs type conversion \n\n// Can check for NaN with isNaN()\nconsole.log(\"isNaN(zeroOverZero):\",\n              isNaN(zeroOverZero));\n\n");

  slide.code("JavaScript Control Flow", null, "let a = [0, 1, 2, 3, 4];\nlet singer = {\n    first_name: \"Kanye\",\n    last_name: \"West\"\n}\n\n\n// If (ALWAYS USE {} BRACES)\nif (a[3] === 3) {\n  console.log(\"if: success\");\n}\nelse {\n  console.log(\"if: failure\");\n}\n\n// For (enumeration)\nfor (let i = 0; i < a.length; i++) {\n  console.log(`a[${i}] = ${a[i]}`);\n}\n\n// For (attr in obj)\nfor (let prop in singer) {\n  // console.log(\"singer[\" + prop + \"] = \",singer[prop])\n  // Example of using string literal\n  console.log(`singer[${prop}] = ${singer[prop]}`)\n}\n\n// While \nwhile (a[4] > 2) {\n  a[4]--;\n  console.log(\"a[4] = \" + a[4]);\n}\n\n// Also notice the increment and \n// decrement operators ++, --\n");

  slide.code("JavaScript Functions", null, "// Functions are JavaScript objects\n\n// Create a variable called add and store\n// a function in it that adds two numbers.\nlet add = function (a, b) { \n  return a + b;\n};\n\n// Can also specify the name directly\n\n// Another (more succint) way: Arrow functions\n// let add = (a, b) => a + b;\n// For an exhaustive list of difference between\n// regular 'function' and arrow '=>' functions\n// Refer https://medium.com/better-programming/difference-between-regular-functions-and-arrow-functions-f65639aba256\n\nconsole.log(\"add(2,3) = \", add(2,3));\n\n// Since functions are objects, they can be stored\n// as 'methods' within other objects\n\n// As Methods, they always recieve the 'this'\n// argument when invoked, which is bound \n// to the object they are a method of\nlet myObject = {\n   value: 0,\n   increment: function (inc) {\n       this.value += inc;\n    } \n};\n\n// Experiment - Replace the above regular function\n// with arrow function and see what happens\n// How does the binding of 'this' differ in an arrow function?\n\n// We will use arrow function throughtout this tutorial\n// as it is more succint\n\nconsole.log(\"myObject.value: \", myObject.value);\nmyObject.increment(2);\nconsole.log(\"myObject.value: \", myObject.value);");

  slide.code("JavaScript Promise", null, "// Promise is a proxy for a value not known when\n// the promise is created\n// For example - Asynchronous REST call\n// Async handlers can be associated with it\n// Lets async methods return values like synchronous methods\n// Promise.then to handle response\n// Promise.catch to handle errors\n// Example - API call\nfetch(\"./data/api.json)\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.log(error))\n\n// NOTE - d3.csv returns a Promise\n// which must be handled in a way similar to above");

  slide.title("Theres even more important parts of JavaScript that could help you, like Closures and Inheritance, but for now this is enough. Check out 'JavaScript: The Good Parts' for more.");

  slide.title("Now some D3...");

  slide.code("Selections: d3.select()", null, "// d3.select(\"selector\") scans the html document\n// and returns the first instance of 'selector'\n// it finds, where 'selector' is a CSS selector\n\n// Since these slides have a \n// <div class=\"out output\"></div>   ----->>>>\n// we select that to work with\n\nlet output_div = d3.select('div.out.output');\n\n// We can then set CSS style of the selected\n// element with .style('name', value)\n\noutput_div.style('background-color', 'blue');\n\n// We can modify all other non-style attributes\n// like 'class' and 'id' with .attr()\n\noutput_div.attr('id', 'main_output');\n");

  slide.code("Adding DOM elements with D3", null, "// First we select the output div \nlet output_div = d3.select('div.output');\n\n// Use .append() to add a DOM element to \n// the end of the selected div\nlet svg = output_div.append('svg');\n\n// Use .attr() to set element attributes\nsvg.attr(\"width\", 400);\nsvg.attr(\"height\", 300);\n\n// Elements can be added within other elements\n// Add a circle to the svg canvas\nlet circle = svg.append(\"circle\");\ncircle.attr(\"cx\", 40);\ncircle.attr(\"cy\", 60);\ncircle.attr(\"r\", 30);\n");

  slide.code("Chaining D3 methods", null, " // D3 .append(), .attr(), and .style() \n // all return the element or elements\n // they operated on, so they can be chained\n // as follows:\n\nlet svg = d3.select('div.output')\n   .append('svg')\n   .attr(\"width\", 400)\n   .attr(\"height\", 300);\n\n // Add a circle\n svg.append(\"circle\")\n   .attr(\"class\", \"myCircles\")\n   .attr(\"id\", \"circle_top\")\n   .attr(\"cx\", 40)\n   .attr(\"cy\", 60)\n   .attr(\"r\", 30);\n\n // Add second circle\n svg.append(\"circle\")\n   .attr(\"class\", \"myCircles\")\n   .attr(\"id\", \"circle_bottom\")\n   .attr(\"cx\", 40)\n   .attr(\"cy\", 120)\n   .attr(\"r\", 20);\n\n // Add a rectangle\n svg.append(\"rect\")\n   .attr(\"x\", 100)\n   .attr(\"y\", 60)\n   .attr(\"width\", 30)\n   .attr(\"height\", 50)\n   .style(\"fill\", \"orange\");\n\n // Add a line\n svg.append(\"line\")\n   .attr(\"x2\", 250)\n   .attr(\"y2\", 90)\n   .attr(\"x1\", 150)\n   .attr(\"y1\", 60)\n   .attr(\"stroke\", \"black\")\n   .attr(\"stroke-width\", 2);");

  slide.title("Check out the same example <a href=\"./../Example_Files/basic_d3.html\" >here</a><br/> Right Click and view the source code to understand  how to use d3 inside HTML ");

  slide.title("Once added, DOM elements can be selected and modified with D3");

  slide.code("SVG Selections", shapes, "/* Given an output div like:\n<div class=\"out output\">\n <svg height=\"300\" width=\"400\">\n   <circle r=\"30\" cy=\"60\" cx=\"40\" \n     id=\"circle_top\" class=\"myCircles\"></circle>\n   <circle r=\"20\" cy=\"120\" cx=\"40\"\n     id=\"circle_bottom\" class=\"myCircles\"></circle>\n   <rect style=\"fill: orange;\" height=\"50\"\n      width=\"30\" y=\"60\" x=\"100\"></rect>\n   <line stroke-width=\"2\" stroke=\"black\" \n       y1=\"60\" x1=\"150\" y2=\"90\" x2=\"250\"></line>\n </svg>\n</div>\n*/\n\n// We can select DOM elements with selector\n// strings (Same as CSS: elem, .class, #id)\nlet circle = d3.select(\"div.output svg\")\n              .select(\"#circle_top\");\n\n// We can also sub-select from selections \nlet rect = d3.select(\"div.output\")\n             .select(\"rect\");\n\n// We can then act on these selections\ncircle.attr(\"fill\", \"red\");\nrect.style(\"fill\", \"purple\");");

  slide.code("Multiple Selections: .selectAll()", shapes, "/* Given an output div like:\n<div class=\"out output\">\n <svg height=\"300\" width=\"400\">\n   <circle r=\"30\" cy=\"60\" cx=\"40\" \n     id=\"circle_top\" class=\"myCircles\"></circle>\n   <circle r=\"20\" cy=\"120\" cx=\"40\"\n     id=\"circle_bot\" class=\"myCircles\"></circle>\n   <rect style=\"fill: orange;\" height=\"50\"\n      width=\"30\" y=\"60\" x=\"100\"></rect>\n   <line stroke-width=\"2\" stroke=\"black\" \n       y1=\"60\" x1=\"150\" y2=\"90\" x2=\"250\"></line>\n </svg>\n</div>\n*/\n\n// We can also select ALL elements which match \nlet circle = d3.selectAll(\".myCircles\");\n\n// We can then act on all these selections\n// simultaneously\ncircle.style(\"fill\", \"steelblue\");");

  slide.code("Acting on Selections Individually", shapes, "/* Given an output div like:\n <div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"30\" cy=\"60\" cx=\"40\" \n      id=\"circle_top\" class=\"myCircles\"></circle>\n    <circle r=\"20\" cy=\"120\" cx=\"40\"\n      id=\"circle_bot\" class=\"myCircles\"></circle>\n    <rect style=\"fill: orange;\" height=\"50\"\n       width=\"30\" y=\"60\" x=\"100\"></rect>\n    <line stroke-width=\"2\" stroke=\"black\" \n        y1=\"60\" x1=\"150\" y2=\"90\" x2=\"250\"></line>\n  </svg>\n</div>\n*/\n\n // Typicall, when selecting SVG elements, we \n // want to select from the SVG canvas to avoid\n // conflicts\n let svg = d3.select(\"div.output\");\n\n // Select all circles\n let circle = svg.selectAll(\"circle\");\n\n // Use an anonymous function which gets\n // evaluated for each element in the selection\n // to set the x coordinate\n circle.attr(\"cx\", () => Math.random() * 400);");

  slide.title("The magic of D3 allows us to then set these element properties based on data");

  slide.code("Binding Data: .data()", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n// Select the SVG canvas\nlet svg = d3.select(\"div.output svg\");\n\n// Select all three circles\nlet circle = svg.selectAll(\"circle\");\n\n// Define our data\nlet dataset = [25, 400, 900];\n\n// Bind the circles to data of our choice\n// based on index\ncircle.data(dataset);\n\n// After the data is bound, it lives\n// in the .__data__ property of the \n// DOM element (CHECK INSPECTOR)\n\n// How to check for __data__?\n// Run the block of code\n// Right click on any circle, select inspect\n// Below the inspector, select \"properties\" tab\n// Expand circle and look for '__data__' property\n\n// This data is then available as the \n// first argument to .attr() and .style()\n// functions (by convention we use d)\ncircle.attr(\"r\", (d) => Math.sqrt(d));\n\n// Bonus Tip: Even shorter syntax\n// circle.attr(\"r\", Math.sqrt);");

  slide.code("Binding Data: .data()", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n // Select the SVG canvas\n let svg = d3.select(\"div.output svg\");\n\n // Select all three circles\n let circle = svg.selectAll(\"circle\");\n\n // Define the data\n let dataset = [25, 400, 900];\n\n // Bind the circles to data of our choice\n // based on index\n circle.data(dataset);\n\n // After the data is bound, it lives\n // in the .__data__ property of the \n // DOM (parent) element (CHECK INSPECTOR)\n\n // This data is then available as the \n // first argument to .attr() and .style()\n // functions (by convention we use d)\n circle.attr(\"r\", (d) => Math.sqrt(d));\n\n // The second argument is the index of the \n // element (by convention we use i)\n circle.attr(\"cy\", (d, i) => i * 100 + 150);");

  slide.title("We can even create new elements for new data");

  slide.code("Entering Elements: .enter()", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n // What if we try to bind 4 data points\n // instead of 3 like last time?\n let dataset = [25, 400, 900, 1600];\n\n // Select the SVG canvas\n let svg = d3.select(\"div.output svg\");\n\n // Select all three circles & bind to\n // our four data points\n let circle = svg.selectAll(\"circle\")\n              .data(dataset);\n\n // Change radius of existing circles based on data\n circle.attr(\"r\", (d) => Math.sqrt(d));\n\n // Then use .enter() to create & select\n // placeholder elements for which we have data \n // but no existing element (datapoint 1600)\n let circleEnter = circle.enter();\n\n // Add a circle for each new data point\n let newCircles = circleEnter.append(\"circle\");\n\n // Now set the properties of the new circle\n newCircles.attr(\"r\", (d) => Math.sqrt(d))\n      .attr(\"cx\",  (d, i) => i * 100 + 40)\n      .attr(\"cy\", 60)\n      .style(\"fill\", \"red\");");

  slide.code("ENTER EVERYTHING", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\n// We can now create elements for all new data\n\n// Select the SVG canvas\nlet svg = d3.select(\"div.output svg\");\n\nlet dataset = [25, 400, 900, 1600];\n\n// Select circles & bind to\n// our four data points\nlet circle = svg.selectAll(\"circle\")\n            .data(dataset);\n\n// Entering now returns all data\nlet circleEnter = circle.enter();\n\n// Add a circle for each new data point\nlet newCircles = circleEnter.append(\"circle\");\n\n// Now set the properties of the new circles\nnewCircles.attr(\"r\", (d) => Math.sqrt(d))\n    .attr(\"cx\",  (d, i) => i * 100 + 40)\n    .attr(\"cy\", 60);");

  slide.code("ENTER EVERYTHING: The pattern", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\n// Select the SVG canvas\nlet svg = d3.select(\"div.output svg\");\n\n// Define the data\nlet dataset = [25, 400, 900, 1600];\n\n// Bind - Enter - Update\nsvg.selectAll(\"circle\")\n    .data(dataset)\n    .enter()\n    .append(\"circle\")\n    .attr(\"r\", (d) => Math.sqrt(d))\n    .attr(\"cx\", (d, i) => i * 100 + 40)\n    .attr(\"cy\", 60);");

  slide.title("And remove elements for missing data");

  slide.code("Exiting Elements: .exit()", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n// What if we instead give the visualization\n// only 2 data points?\nlet dataset = [25, 400];\n\n// Select the SVG canvas\nlet svg = d3.select(\"div.output svg\");\n\n// Select all three circles & bind to\n// our two data points\nlet circle = svg.selectAll(\"circle\")\n            .data(dataset);\n\n// Change radius of existing circles based on data\ncircle.attr(\"r\", (d) => Math.sqrt(d))\n\n// Here .exit() returns the elements for which\n// no corresponding data point was bound.\ncircle.exit().remove();\n\n// If the data doesnt exist, remove the circle!");

  slide.title("To assist visualization, D3 provides scales to convert from a specified domain to a specified range");

  slide.code("Scales", null, "// Given a canvas width and height\nlet w = 420, h = 320;\n\n// We use d3.scaleLinear() to \n// return a function which converts\n// from our data domain to the \n// canvas pixel domain\n\n// x is a function!\nlet x = d3.scaleLinear()\n  // Domain is input\n  .domain([-1, 1])\n  // Range is output\n  .range([0, w])\n\n// y is also a function!\nlet y = d3.scaleLinear()\n  .domain([0, 1000])\n  .range([0, h])\n\nconsole.log(\"x(-1) ==\", x(-1)) // == 0\nconsole.log(\"x(0) ==\", x(0)) // == w/2\nconsole.log(\"x(1) ==\", x(1)) // == w\n\nconsole.log(\"y(900) ==\", y(900)) // == h*9/10\n");

  slide.code("A basic scaled barchart", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\nlet svg = d3.select(\"div.output svg\");\n\nlet data = [4, 8, 15, 16, 23, 42];\n\nlet width = 500,\n    height = 666;\n\n// Define the bar thickness to be an even\n// division of the svg height\nlet barHeight = height / data.length;\n\n// Create an xScale which maps from data\n// values to x coordinates\nlet xScale = d3.scaleLinear()\n    .domain([0, d3.max(data)])\n    .range([0, width]);\n\n// For each data point, create a group\n// which translates all elements to the \n// correct y coordinate\nlet bar = svg.selectAll(\"g\")\n    .data(data)\n    .enter()\n    .append(\"g\")\n    .attr(\"transform\", (d, i) => `translate(0, ${i * barHeight})`);\n\n// bar now holds all newly created groups\n\n// Add an SVG rect of width = xScale(datum)\nbar.append(\"rect\")\n    .attr(\"width\", (d) => xScale(d))\n    .attr(\"height\", barHeight - 1)\n    .style(\"fill\", \"steelblue\")\n    .style(\"stroke\", \"white\");\n\n// Add SVG text the end of the bar displaying\n// the value of the data\nbar.append(\"text\")\n    .attr(\"x\", (d) => xScale(d) - 5)\n    .attr(\"y\", barHeight / 2)\n    .attr(\"dy\", \".35em\")\n    .text(d => d)\n    .style(\"fill\", \"white\")\n    .style(\"text-anchor\", \"end\");");

  slide.code("Flipping the barchart", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\nlet svg = d3.select(\"div.output svg\");\n\nlet data = [4, 8, 15, 16, 23, 42];\n\nlet width = 500,\n    height = 666,\n    barWidth = width / data.length - 10;\n\nlet y_scale = d3.scaleLinear()\n    .domain([0, d3.max(data)])\n    .range([0, height]);\n\nlet x_scale = d3.scaleLinear()\n    .domain([0, data.length])\n    .range([0, width]);\n\n// Create a bar for each data point\nlet bar = svg.selectAll(\"rect\")\n    .data(data)\n  .enter().append(\"rect\")\n    .attr(\"x\", (d, i) => x_scale(i))\n    .attr(\"y\", (d) => height - y_scale(d))\n    .attr(\"width\", barWidth)\n    .attr(\"height\", (d) => y_scale(d))\n    .style(\"fill\", \"steelblue\")\n    .style(\"stroke\", \"white\");\n\n// Create a text label for each data point\nsvg.selectAll(\"text\")\n    .data(data)\n    .enter().append(\"text\")\n    .attr(\"x\", (d, i) => x_scale(i) + barWidth / 2)\n    .attr(\"y\", (d) => height - y_scale(d) + 20)\n    .text(d => d)\n    .style(\"fill\", \"white\")\n    .style(\"text-anchor\", \"middle\");");

  slide.code("Basic Scatterplot", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\n// Select the svg canvas\nlet svg = d3.select(\"div.output svg\");\n\nlet data = \n  [[5, 20], [480, 90], [250, 50], [100, 33], [330, 95],\n   [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]];\n\nlet width = 500,\n    height = 666;\n\n// Compute the maximum values for the scales\nlet x_max = d3.max(data, d => d[0]);\n\nlet y_max = d3.max(data, d => d[1]);\n\n// Define two linear scales for the \n// x & y values\nlet x_scale = d3.scaleLinear()\n    .domain([0, x_max])\n    .range([0, width]);\n\nlet y_scale = d3.scaleLinear()\n    .domain([0, y_max])\n    .range([0, height]);\n\n// Bind - enter - update circles with\n// coordinates given by the scaled data\nsvg.selectAll(\"circle\") \n   .data(data)\n   .enter()\n   .append(\"circle\")\n   .attr(\"cx\", (d) => x_scale(d[0]))\n   .attr(\"cy\", (d) => y_scale(d[1]))\n   .attr(\"r\", 5);");

  slide.code("Basic Histogram", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n//generate random data\nlet data = d3.range(1000).map(d3.randomBates(10));\n\nlet formatCount = d3.format(\",.0f\");\n\n//Initialize width, height. Select SVG and add svg group \"g\"\nlet svg = d3.select(\"div.output svg\"),\n    margin = {top: 20, right: 30, bottom: 30, left: 30},\n    width = 500 - margin.left - margin.right,\n    height = +svg.attr(\"height\") - margin.top - margin.bottom,\n    g = svg.append(\"g\").attr(\"transform\", `translate(${margin.left}, ${margin.top})`);\n\n//Define XScales\nlet x = d3.scaleLinear()\n    .rangeRound([0, width]);\n\n//Define Histogram bins\nlet bins = d3.histogram()\n    .domain(x.domain())\n    (data);\n\n//Define YScales using bins\nlet y = d3.scaleLinear()\n    .domain([0, d3.max(bins, d => d.length)])\n    .range([height, 0]);\n\n//Generate Histogram\nlet bar = g.selectAll(\".bar\")\n  .data(bins)\n  .enter().append(\"g\")\n    .attr(\"class\", \"bar\")\n    .attr(\"transform\", (d) => `translate(${x(d.x0)}, ${y(d.length)})`);\n\nbar.append(\"rect\")\n    .attr(\"x\", 1)\n    .attr(\"width\", x(bins[0].x1) - x(bins[0].x0) - 1)\n    .attr(\"height\", (d) => height - y(d.length))\n    .style(\"fill\",\"lightblue\");\n\nbar.append(\"text\")\n    .attr(\"dy\", \"-.75em\")\n    .attr(\"y\", 6)\n    .attr(\"x\", (x(bins[0].x1) - x(bins[0].x0)) / 2)\n    .attr(\"text-anchor\", \"middle\")\n    .text((d) => formatCount(d.length));\n\ng.append(\"g\")\n    .attr(\"class\", \"axis axis--x\")\n    .attr(\"transform\", `translate(0,${height})`)\n    .call(d3.axisBottom(x));");

  slide.title("D3 also makes animations between properties easy");

  slide.code("Basic Transition", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n // Select the SVG canvas\n let svg = d3.select(\"div.output svg\");\n\n// Select our circles and bind new data\nlet circle = svg.selectAll(\"circle\")\n            .data([25, 400, 900]);\n\n// Apply transition of duration 2 seconds\n// and update properties of all circles \n// based on new data\ncircle.transition()\n      .duration(2000)\n      .attr(\"r\", (d) => Math.sqrt(d))\n      .attr(\"cx\", (d, i) => i * 100 + 40)\n      .attr(\"cy\", (d, i) => i * 100 + 150);");

  slide.code("Transitions For New Elements", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n// Select the SVG canvas\n let svg = d3.select(\"div.output svg\");\n\n// Select our circles and bind new data\nlet circle = svg.selectAll(\"circle\")\n            .data([25, 400, 900, 1600]);\n\n// Define initial properties for new circle\n// Apply transition of duration 2 seconds\n// and update properties of all circles \n// based on data\ncircle.enter()\n  .append(\"circle\")\n  .attr(\"r\", 0)\n  .attr(\"cx\", 400)\n  .attr(\"cy\", 300)\n  .style(\"fill\", \"red\")\n      .merge(circle) \n\n      // allows transition to be applied on the newly entered circle \n          .transition()\n          .duration(2000)\n          .attr(\"r\", (d) => Math.sqrt(d))\n          .attr(\"cy\", (d, i) => i * 100 + 150);");

  slide.code("Transitioning in the barchart", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\nlet svg = d3.select(\"div.output svg\");\n\nlet data = [4, 8, 15, 16, 23, 42];\n\nlet width = 500,\n    height = 666,\n    barWidth = width / data.length - 10;\n\nlet y_scale = d3.scaleLinear()\n    .domain([0, d3.max(data)])\n    .range([0, height]);\n\nlet x_scale = d3.scaleLinear()\n    .domain([0, data.length])\n    .range([0, width]);\n\n// Create a bar for each data point\nlet bar = svg.selectAll(\"rect\")\n    .data(data)\n  .enter().append(\"rect\")\n    .attr(\"x\", (d, i) => x_scale(i))\n    .attr(\"y\", (d) => height)\n    .attr(\"width\", barWidth)\n    .attr(\"height\", (d) => y_scale(d))\n    .style(\"fill\", \"steelblue\")\n    .style(\"stroke\", \"white\");\n\n// Transition to the correct y location\nbar.transition().duration(2000)\n    .attr(\"y\", (d) => height - y_scale(d));\n\n// Create a text label for each data point\nlet text = svg.selectAll(\"text\")\n    .data(data)\n    .enter().append(\"text\")\n    .attr(\"x\", (d, i) => x_scale(i) + barWidth / 2)\n    .attr(\"y\", height)\n    .text((d) => d)\n    .style(\"fill\", \"white\")\n    .style(\"text-anchor\", \"middle\");\n\n// Transition text to correct height\ntext.transition().duration(2000)\n    .attr(\"y\", (d) => height - y_scale(d) + 20);");

  // -----------------------------------------------
  slide.title("Binding data by key");

  slide.code_title(title = ".data(..., join)");

  init_svg = function() {
    var svg;
    svg = d3.select("div.output").append("svg");
    return svg.selectAll("rect").data([127, 61, 256]).enter().append("rect").attr("x", 0).attr("y", function(d, i) {
      return i * 90 + 50;
    }).attr("width", function(d, i) {
      return d;
    }).attr("height", 20).style("fill", "steelblue");
  };

  slide.code(title, init_svg, "let svg = d3.select(\"div.output svg\")\n\n// Let's say we start here:\n/*\nsvg.selectAll(\"rect\")\n  .data([127, 61, 256])\n  .enter().append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", (d,i) => i*90+50)\n    .attr(\"width\", (d,i) => d)\n    .attr(\"height\", 20)\n    .style(\"fill\", \"steelblue\")\n*/\n\n// And then we bind new data by index\nlet selection = svg.selectAll(\"rect\")\n  .data([61, 256, 71]) \n\n// Create rectangles for new data (NONE)\nselection.enter().append(\"rect\")\n  .attr(\"x\", 0)\n  .attr(\"y\", (d,i) => i*90+50 )\n  .attr(\"width\", (d,i) => d)\n  .attr(\"height\", 20)\n  .style(\"fill\", \"steelblue\")\n// Transition old rectangles to new y and \n// width based on the new data\n    .merge(selection)\n      .transition()\n      .duration(3000)\n        .attr(\"x\", 0)\n        .attr(\"y\", (d,i) => i*90+50 )\n        .attr(\"width\", (d,i) => d)\n        .attr(\"height\", 20)\n        .style(\"fill\", \"steelblue\")\n\n// Remove rectangles for which we have no bound\n// data (NONE since we bound by index)\nselection.exit()\n  .remove()");

  // -----------------------------------------------
  slide.title("Loading External Data");

  slide.code("d3.csv()", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\n/* And a datafile data.csv:\n      name,value\n      Locke,4\n      Reyes,8\n      Ford,15\n      Jarrah,16\n      Shephard,23\n      Kwon,42\n*/\n\nlet width = 450,\n    height = 666;\n\nlet x = d3.scaleLinear()\n    .range([0, width]);\n\nlet chart = d3.select(\"div.output svg\");\n\n// d3.csv takes 3 arguments:\n// filename, accessor, callback\n\n// The accessor is a function which takes \n// each row of the data and returns a converted\n// version:\nfunction type(d) {\n  d.value = +d.value; // coerce to number\n  return d;\n}\n\n// This converted version is passed to the\n// third argument, the callback function\n// All processing happens inside this function\n\nd3.csv(\"data/data.csv\")\n  .then((data) => {\n    let barHeight = height / data.length;\n\n  x.domain([0, d3.max(data, (d) => +d.value)]);\n\n  chart.attr(\"height\", barHeight * data.length);\n\n  let bar = chart.selectAll(\"g\")\n      .data(data)\n    .enter().append(\"g\")\n      .attr(\"transform\", (d, i) => `translate(0, ${i * barHeight})`);\n\n  bar.append(\"rect\")\n      .attr(\"width\", (d) => x(d.value))\n      .attr(\"height\", barHeight - 1);\n\n  bar.append(\"text\")\n      .attr(\"x\", (d) => x(d.value) - 25)\n      .attr(\"y\", barHeight / 2)\n      .attr(\"dy\", \".35em\")\n      .text((d) => d.value);\n  })\n  .catch((error) => console.log(error));\n");

  // -----------------------------------------------
  slide.title("D3 Data Processing");

  slide.code("d3.group()", null, "// Given an yields of items\nlet yields = [\n  {yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"},\n  {yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"},\n  {yield: 27.43, variety: \"Manchuria\", year: 1932, site: \"Morris\"},\n  {yield: 27.43, variety: \"Chowmein\", year: 1932, site: \"Morris\"},\n  {yield: 27.00, variety: \"Manchuria\", year: 1932, site: \"University Farm\"},\n  {yield: 48.87, variety: \"Dumpling\", year: 1933, site: \"Waseca\"},\n  {yield: 27.43, variety: \"Manchuria\", year: 1933, site: \"Morris\"},\n  {yield: 27.43, variety: \"Chowmein\", year: 1935, site: \"Morris\"}\n];\n\n// Grouping allows elements in an array to \n// be grouped into a hierarchical tree structure; \n// Think of it like the GROUP BY operator in SQL\nlet entries = d3.group(yields, d => d.year)\n\n// Convert MapIterator to Array\n// Reference for object spread operator\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\nentries = [...entries]\n\n//Print JSON in pretty format\nconsole.log(JSON.stringify(\n                 entries,undefined,2))");

  slide.code("d3.rollup()", null, "// Given an yields data\nlet data = [\n  {name: \"jim\",   amount: \"34.0\",   date: \"11/12/2015\"},\n  {name: \"carl\",  amount: \"120.11\", date: \"11/12/2015\"},\n  {name: \"stacy\", amount: \"12.01\",  date: \"01/04/2016\"},\n  {name: \"stacy\", amount: \"34.05\",  date: \"01/04/2016\"}\n]\n\n// Groups and reduces the specified iterable of \n// values into a Map from key to value\nlet entries = d3.rollup(data, v => v.length, d => d.name)\n\n// Convert from MapIterator to Array\nentries = [...entries]\n\n//Print JSON in pretty format\nconsole.log(JSON.stringify(\n                 entries,undefined,2))\n\n// Refer https://github.com/d3/d3-array/blob/master/README.md#rollup");

  slide.title("Check more on groups, rollup etc. at <a target=\"_blank\" href=\"https://github.com/d3/d3-array/blob/master/README.md#group\">here</a>");

  // -----------------------------------------------
  slide.title("Advanced Scales");

  slide.code("Advanced Scales", empty_svg, "let w = 450,\n    h = 500;\n\nlet years = [\"1992\", \"1996\", \"2000\", \"2004\"];\nlet positions = [100, 200, 300, 400];\n\n// Ordinal scales map discrete values by index\nlet xScale = d3.scaleOrdinal()\n                .domain(years)\n                .range(positions);\n\nconsole.log(\"xScale('2000'): \", xScale(\"2000\"));\n\n// ScaleBands are like ordinal scales except \n// the output range is continuous and numeric.\n// rangeRound() create the range by diving the given interval into \n// bands of even size (with rounded values)\n\nxScale =  d3.scaleBand()\n                .domain(years)\n                .rangeRound([0, w])\n                .padding(0.05)\n\nconsole.log(\"xScale('2000'): \", xScale(\"2000\"));\n\n// There is also a .bandwidth() method which \n// returns the size of the band\nconsole.log(\"xScale.bandwidth(): \", \n              xScale.bandwidth());");

  // -----------------------------------------------
  slide.title("Adding Axes");

  slide.code("Adding Axes", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"600\" width=\"500\"></svg>\n</div>\n*/\n\n// Select the SVG canvas\nlet svg = d3.select('div.output svg');\n\n// Given a canvas width and height\nlet w = 500, h = 600, padding = 100;\n\n// First get the scales\nlet xScale = d3.scaleLinear()\n  .domain([-1, 1])\n  .range([0, w])\n\nlet yScale = d3.scaleLinear()\n  .domain([0, 1000])\n  .range([0, h])\n\n/* Define the axes using axes\norientation and scale functions\nFor orientation we use:\naxisLeft,axisRight,axisTop or axisBottom\n*/\nlet xAxis = d3.axisBottom(xScale);  \nlet yAxis = d3.axisLeft(yScale);\n\n// To actually draw the SVG axis to the screen\n// we have to say 'where' and give it something\n// to be drawn in (like a <g> tag). We then use\n// .call() to call the Axis drawing functions\nsvg.append(\"g\")\n    .attr(\"transform\", `translate(0, ${h})`)\n    .call(xAxis);\n\nsvg.append(\"g\")\n    .attr(\"transform\", `translate(${padding}, 0)`)\n    .call(yAxis);\n");

  // -----------------------------------------------
  slide.title("Interesting Examples");

  slide.code("Force-Directed Graph", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"600\" width=\"500\"></svg>\n</div>\n*/\n\nlet svg = d3.select(\"div.output\").select(\"svg\"),\n    width = +svg.attr(\"width\"),\n    height = +svg.attr(\"height\");\n\nlet color = d3.scaleOrdinal(d3.schemeCategory10);\n\nlet simulation = d3.forceSimulation()\n    .force(\"link\", d3.forceLink().id((d) => d.id))\n    .force(\"charge\", d3.forceManyBody())\n    .force(\"center\", d3.forceCenter(width / 2, height / 2));\n\nd3.json(\"data/miserables.json\")\n  .then((graph) => {\n    console.log(graph);\n    let link = svg.append(\"g\")\n    .attr(\"class\", \"links\")\n    .selectAll(\"line\")\n    .data(graph.links)\n    .enter().append(\"line\")\n    .attr(\"stroke-width\", (d) => Math.sqrt(d.value))\n    .attr(\"stroke\",\"#999\");\n\n  let node = svg.append(\"g\")\n    .attr(\"class\", \"nodes\")\n    .selectAll(\"circle\")\n    .data(graph.nodes)\n    .enter()\n    .append(\"circle\")\n      .attr(\"r\", 5)\n      .attr(\"fill\", (d) => color(d.group))\n      .call(d3.drag()\n          .on(\"start\", dragstarted)\n          .on(\"drag\", dragged)\n          .on(\"end\", dragended));\n\n  node.append(\"title\")\n      .text((d) => d.id);\n\n  simulation\n      .nodes(graph.nodes)\n      .on(\"tick\", ticked);\n\n  simulation.force(\"link\")\n      .links(graph.links);\n\n  function ticked() {\n    link\n        .attr(\"x1\", (d) => d.source.x)\n        .attr(\"y1\", (d) => d.source.y)\n        .attr(\"x2\", (d) => d.target.x)\n        .attr(\"y2\", (d) => d.target.y);\n\n    node\n        .attr(\"cx\", (d) => d.x)\n        .attr(\"cy\", (d) => d.y);\n  }\n  })\n  .catch(error => console.log(error));\n\nfunction dragstarted(d) {\n  if (!event.active) simulation.alphaTarget(0.3).restart();\n  d.fx = d.x;\n  d.fy = d.y;\n}\n\nfunction dragged(d) {\n  d.fx = d3.event.x;\n  d.fy = d3.event.y;\n}\n\nfunction dragended(d) {\n  if (!d3.event.active) simulation.alphaTarget(0);\n  d.fx = null;\n  d.fy = null;\n}");

  slide.code("Expandible Dendrite Plot", null, "let treeData =\n  {\n    \"name\": \"Top Level\",\n    \"children\": [\n      { \n        \"name\": \"Level 2: A\",\n        \"children\": [\n          { \"name\": \"Son of A\" },\n          { \"name\": \"Daughter of A\" }\n        ]\n      },\n      { \"name\": \"Level 2: B\" }\n    ]\n  };\n\n// Set the dimensions and margins of the diagram\nlet margin = {top: 20, right: 90, bottom: 30, left: 90},\n    width = 380 - margin.left - margin.right,\n    height = 666 - margin.top - margin.bottom;\n\n// append the svg object to the body of the page\n// appends a 'group' element to 'svg'\n// moves the 'group' element to the top left margin\nlet svg = d3.select(\"div.output\").append(\"svg\")\n    .attr(\"width\", width + margin.right + margin.left)\n    .attr(\"height\", height + margin.top + margin.bottom)\n  .append(\"g\")\n    .attr(\"transform\", `translate(${margin.left}, ${margin.top})`);\n\nlet i = 0,\n    duration = 750,\n    root;\n\n// declares a tree layout and assigns the size\nlet treemap = d3.tree().size([height, width]);\n\n// Assigns parent, children, height, depth\nroot = d3.hierarchy(treeData, (d) => d.children);\nroot.x0 = height / 2;\nroot.y0 = 0;\n\n// Collapse after the second level\nroot.children.forEach(collapse);\n\nupdate(root);\n\n// Collapse the node and all it's children\nfunction collapse(d) {\n  if(d.children) {\n    d._children = d.children\n    d._children.forEach(collapse)\n    d.children = null\n  }\n}\n\nfunction update(source) {\n\n  // Assigns the x and y position for the nodes\n  let treeData = treemap(root);\n\n  // Compute the new tree layout.\n  let nodes = treeData.descendants(),\n      links = treeData.descendants().slice(1);\n\n  // Normalize for fixed-depth.\n  nodes.forEach((d) => { d.y = d.depth * 180});\n\n  // ****************** Nodes section ***************************\n\n  // Update the nodes...\n  let node = svg.selectAll('g.node')\n      .data(nodes, (d) => d.id || (d.id = ++i));\n\n  // Enter any new modes at the parent's previous position.\n  let nodeEnter = node.enter().append('g')\n      .attr('class', 'node')\n      .attr(\"transform\", (d) => `translate(${source.y0},  ${source.x0})`)\n    .on('click', click);\n\n  // Add Circle for the nodes\n  nodeEnter.append('circle')\n      .attr('class', 'node')\n      .attr('r', 1e-6)\n      .style(\"fill\", (d) => d._children ? \"lightsteelblue\" : \"#fff\")\n      .attr(\"stroke\",\"#ccc\");\n\n  // Add labels for the nodes\n  nodeEnter.append('text')\n      .attr(\"dy\", \".35em\")\n      .attr(\"x\", (d) => d.children || d._children ? -13 : 13)\n      .attr(\"text-anchor\", (d) => d.children || d._children ? \"end\" : \"start\")\n      .text((d) => d.data.name);\n\n  // UPDATE\n  let nodeUpdate = nodeEnter.merge(node);\n\n  // Transition to the proper position for the node\n  nodeUpdate.transition()\n    .duration(duration)\n    .attr(\"transform\", (d) => `translate(${d.y}, ${d.x})`);\n\n  // Update the node attributes and style\n  nodeUpdate.select('circle.node')\n    .attr('r', 10)\n    .style(\"fill\", (d) => d._children ? \"lightsteelblue\" : \"#fff\")\n    .attr('cursor', 'pointer');\n\n\n  // Remove any exiting nodes\n  let nodeExit = node.exit().transition()\n      .duration(duration)\n      .attr(\"transform\", (d) => `translate(${source.y}, ${source.x})`)\n      .remove();\n\n  // On exit reduce the node circles size to 0\n  nodeExit.select('circle')\n    .attr('r', 1e-6);\n\n  // On exit reduce the opacity of text labels\n  nodeExit.select('text')\n    .style('fill-opacity', 1e-6);\n\n  // ****************** links section ***************************\n\n  // Update the links...\n  let link = svg.selectAll('path.link')\n      .data(links, (d) => d.id);\n\n  // Enter any new links at the parent's previous position.\n  let linkEnter = link.enter().insert('path', \"g\")\n      .attr(\"class\", \"link\")\n      .attr('d', (d) => {\n        let o = {x: source.x0, y: source.y0}\n        return diagonal(o, o)\n      }).attr(\"stroke\",\"#ccc\") \n        .attr(\"stroke-width\",\"2px\")\n        .attr(\"fill\",\"None\")\n\n\n  // UPDATE\n  let linkUpdate = linkEnter.merge(link);\n\n  // Transition back to the parent element position\n  linkUpdate.transition()\n      .duration(duration)\n      .attr('d', (d) => diagonal(d, d.parent));\n\n  // Remove any exiting links\n  let linkExit = link.exit().transition()\n      .duration(duration)\n      .attr('d', (d) => {\n        let o = {x: source.x, y: source.y}\n        return diagonal(o, o);\n      })\n      .remove();\n\n  // Store the old positions for transition.\n  nodes.forEach((d) => {\n    d.x0 = d.x;\n    d.y0 = d.y;\n  });\n\n  // Creates a curved (diagonal) path from parent to the child nodes\n  function diagonal(s, d) {\n\n    let path = `M ${s.y} ${s.x}\n            C ${(s.y + d.y) / 2} ${s.x},\n              ${(s.y + d.y) / 2} ${d.x},\n              ${d.y} ${d.x}`\n\n    return path\n  }\n\n  // Toggle children on click.\n  function click(d) {\n    if (d.children) {\n        d._children = d.children;\n        d.children = null;\n      } else {\n        d.children = d._children;\n        d._children = null;\n      }\n    update(d);\n  }\n}");

}).call(this);